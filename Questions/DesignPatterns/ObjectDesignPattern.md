<div dir="rtl">

# استفاده از الگوی طراحی Object Method در سیستم‌های نهفته

این راهنما قراره بهت کمک کنه تا با استفاده از الگوی طراحی Object Method بتونی یک سیستم کنترل سنسور و دستگاه‌های دیگه رو توی محیط‌های نهفته یا حتی ویندوزی پیاده‌سازی کنی. همچنین یک سری تمرین برات در نظر گرفتیم تا درک و مهارتت رو تو این زمینه تقویت کنی.

## سناریو: استفاده از الگوی طراحی Object Method

فرض کن داری یک سیستم نهفته طراحی می‌کنی که با دستگاه‌های مختلفی مثل موتورها، سنسورها و نمایشگرها کار می‌کنه. هدف اینه که برای هر دستگاه یک شیء درست کنیم که شامل ویژگی‌ها (مثل سرعت و جهت برای موتورها) و عملیات (مثل تنظیم سرعت و جهت) باشه. این روش کمک می‌کنه که کدت مرتب‌تر و قابل نگهداری‌تر بشه.

### مرحله 1: پیاده‌سازی ساده بدون استفاده از Object Method

اول فرض کن که بدون استفاده از Object Method، برنامه‌نویسی می‌کنی. هر ویژگی و عملیاتی به صورت جداگانه و بدون انسجام خاصی تعریف می‌شه.

#### 1.1 تعریف ویژگی‌ها و عملیات برای موتور

فرض کن باید سرعت و جهت یک موتور رو تنظیم کنی. کد به این شکل خواهد بود:

<div dir="ltr">


```c
int motor_speed;
int motor_direction;

void set_motor_speed(int speed) {
    motor_speed = speed;
    // کد برای تنظیم سرعت موتور
}

void set_motor_direction(int direction) {
    motor_direction = direction;
    // کد برای تنظیم جهت موتور
}
```
</div>

#### 1.2 استفاده از عملیات در برنامه اصلی

برای استفاده از این توابع، باید به صورت جداگانه هر عملیات رو فراخوانی کنی و متغیرهای مرتبط رو مدیریت کنی:


<div dir="ltr">

```c
int main(void) {
    set_motor_speed(100);
    set_motor_direction(1);

    while (1) {
        // حلقه اصلی برنامه
    }

    return 0;
}
```

</div>

### مشکلات روش بدون Object Method

1. **عدم انسجام:** داده‌ها و عملیات‌های مرتبط به صورت جداگانه تعریف می‌شن و انسجام کافی ندارن.

2. **مدیریت پیچیده:** اگه بخوای چند تا موتور یا دستگاه دیگه رو کنترل کنی، مدیریت داده‌ها و عملیات‌ها به صورت دستی سخت و پیچیده می‌شه.

3. **افزودن دستگاه جدید:** هر بار که یک دستگاه جدید اضافه می‌کنی، باید کدهای مشابهی براش بنویسی و تو برنامه اصلی هم تغییرات زیادی انجام بدی.

### مرحله 2: استفاده از الگوی Object Method

حالا بیا از الگوی طراحی Object Method استفاده کنیم.

#### 2.1 تعریف یک ساختار برای موتور

اول یک ساختار برای موتور تعریف می‌کنیم که شامل ویژگی‌ها و توابع مرتبط بهش می‌شه:

<div dir="ltr">


```c
typedef struct {
    int speed;
    int direction;
    void (*set_speed)(struct Motor* self, int speed);
    void (*set_direction)(struct Motor* self, int direction);
} Motor;
```

</div>

#### 2.2 پیاده‌سازی متدهای موتور

سپس متدهایی رو که برای هر موتور اعمال می‌شن، پیاده‌سازی می‌کنیم. این متدها با استفاده از اشاره‌گر به خود شیء (self) کار می‌کنن:

<div dir="ltr">

```c
void set_motor_speed(Motor* self, int speed) {
    self->speed = speed;
    // کد برای تنظیم سرعت موتور
}

void set_motor_direction(Motor* self, int direction) {
    self->direction = direction;
    // کد برای تنظیم جهت موتور
}
```

</div>

#### 2.3 ایجاد و مقداردهی اولیه شیء موتور

در این مرحله، شیء موتور رو ایجاد می‌کنیم و اشاره‌گرهای مربوط به متدها رو بهش تخصیص می‌دیم:

<div dir="ltr">


```c
Motor* create_motor() {
    Motor* motor = (Motor*)malloc(sizeof(Motor));
    motor->speed = 0;
    motor->direction = 0;
    motor->set_speed = set_motor_speed;
    motor->set_direction = set_motor_direction;
    return motor;
}
```

</div>

#### 2.4 استفاده از شیء موتور در برنامه اصلی

حالا می‌تونیم از شیء موتور و متدهای اون به صورت منسجم و سازمان‌یافته استفاده کنیم:

<div dir="ltr">

```c
int main(void) {
    // ایجاد شیء موتور
    Motor* myMotor = create_motor();

    // تنظیم سرعت و جهت موتور
    myMotor->set_speed(myMotor, 100);
    myMotor->set_direction(myMotor, 1);

    while (1) {
        // حلقه اصلی برنامه
    }

    // آزادسازی حافظه
    free(myMotor);

    return 0;
}
```

</div>

### مزایای استفاده از Object Method

1. **انسجام کد:** داده‌ها و عملیات‌های مرتبط به هم در یک ساختار قرار می‌گیرن که باعث افزایش انسجام کد می‌شه.

2. **مدیریت ساده‌تر:** با استفاده از شیء و متدها، مدیریت دستگاه‌ها ساده‌تر و منظم‌تر می‌شه.

3. **قابلیت گسترش:** افزودن دستگاه‌های جدید فقط با تعریف یک ساختار و متدهای مرتبط به اون انجام می‌شه، بدون نیاز به تغییرات بزرگ در کد اصلی.

</div>
